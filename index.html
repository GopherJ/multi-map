<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Multi-map by thejpster</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Multi-map</h1>
      <h2 class="project-tagline">Like a Rust std::collection::HashMap, but allows you to use either of two different keys to retrieve items.</h2>
      <a href="https://github.com/thejpster/multi-map" class="btn">View on GitHub</a>
      <a href="https://github.com/thejpster/multi-map/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/thejpster/multi-map/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h3>
<a id="multi-map" class="anchor" href="#multi-map" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Multi-Map</h3>

<p>Sometimes, when developing software stacks, a layer will have some context object it needs to store. Assume, for example, we have an HTTP module, which sits below some sort of HTTP-using Application, and above a Socket module.</p>

<p>When a new connection is created, a message is received from the Socket module with the ID of the new connection. A new HTTP Connection object is created, and stored against the Socket ID, so that it can be easily retrieved when data arrives on the Socket. But to inform the layer above about the new HTTP Connection (as distinct from any other HTTP Connections that may be on going), we need to give the HTTP Connection itself a unique ID, and we need some mechanism of locating the HTTP Connection by this ID as well.</p>

<p>The trivial solution is to store the HTTP Connections in a list, and then iterate them, looking for a matching Socket ID or a matching HTTP Connection ID. But this is slow.</p>

<p>A HashMap seems like a good idea, but you can only key on either the HTTP ID or the Socket ID, not on both.</p>

<p>This module allows you to create a MultiMap - a map which you can look up either by the primary key (HttpID) or an alternative ID (SocketID). Internally, it uses two maps, one on (K1, (K2, V)) and another on (K2, K1).</p>

<p>Insert, removal and iteration is supported. Gradually, I might implement the rest of the std::collections::HashMap API, but I've found this to be sufficiently useful for now.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/thejpster/multi-map">Multi-map</a> is maintained by <a href="https://github.com/thejpster">thejpster</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
